DO_EXAMPLE = True
DO_EXAMPLE = False

def combo(alu, raw_val):
    if raw_val >= 0 and raw_val <= 3:
        return raw_val
    elif raw_val == 4:
        return alu["A"]
    elif raw_val == 5:
        return alu["B"]
    elif raw_val == 6:
        return alu["C"]
    else:
        raise ValueError(f"Can not use raw value {raw_val} in combo resolution.")

# Returns the output generated by running a pre-set program on an octputer's ALU.
def octpute(alu, is_debugging=False): # get it? it's an octal based computer!
    if is_debugging:
        print(f"Running program {','.join(str(x) for x in alu['prg'])}, regA={alu['A']}")
    while alu["IP"] < len(alu["prg"]):
        opcode = alu["prg"][alu["IP"]]
        arg = alu["prg"][alu["IP"]+1]

        if opcode == 0: # adv (division of A register)
            alu["A"] //= 2 ** combo(alu, arg)
        elif opcode == 1: # bxl (bitwise XOR of B and literal operand)
            alu["B"] ^= arg
        elif opcode == 2: # bst (set B to value of combo operand modulo eight)
            alu["B"] = combo(alu, arg) % 8
        elif opcode == 3: # jnz (jump-not-zero on A register)
            if alu["A"] != 0:
                alu["IP"] = arg # note: arg here is taken by value, not combo-resolved.
                continue # this instruction will NOT automatically increment IP by 2 at the end.

        elif opcode == 4: # bxc (bitwise-xor B and C, store in B. So B ^= C)
            alu["B"] ^= alu["C"] # note: this instruction "reads" an operand but "ignores" it.
        elif opcode == 5: # out (append combo operand modulo eight to the output)
            alu["out"].append(combo(alu, arg) % 8)
        elif opcode == 6: # bdv (like adv, but store result in B register)
            alu["B"] = alu["A"] // 2 ** combo(alu, arg)
        elif opcode == 7: # cdv (like adv, but store result in C register)
            alu["C"] = alu["A"] // 2 ** combo(alu, arg)
        else:
            raise RuntimeError(f"Tried to process unknown opcode: {opcode}.")
        alu["IP"] += 2 # past opcode and arg.
    if is_debugging:
        print(f"Returning: {','.join(str(o) for o in alu['out'])}")
    return alu["out"]


# The `input` program does in each loop:
# B = A % 8
# B = B XOR 3
# C = A // (2 ^ B)
# B = B XOR 5
# A = A // 8 # note: shr 3
# B = B XOR C
# OUT B % 8
# JNZ A

# This should be enough information to construct the program from the grounds up.
# A has to be a large number, as we want 16 digits, and each digit requires SHR 3.
# So A is some 48-bit number. That's some 14-15 digits in decimal.
# No wonder brute force approach didn't work.

# To reconstruct the program, start with A=0, then for each number in the program REVERSED:
# a) this can probably be reversed, but the easiest way to go is just try each number in [0..7].
#    if it produces the nth-last-digit of program, then:
# b) multiply A by 8
# c) add the value from a) to A.
# After 16 steps the value of A should result in a quine being printed.

# Some output digits can be generated by more than one input number i.
# Need to try all such combinations in order from lowest to highest,
# in order to get the smallest input for which a quine is printed.


# Searches for the initial value of A register such that the program code
# will appear verbatim on the output.
def find_quine(program_as_numbers, regA, idx):
    for i in range(8):
        alu = {
            "A": regA + i,
            "B": 0,
            "C": 0,
            "IP": 0,
            "out": [],
            "prg": program_as_numbers,
        }
        out = octpute(alu)
        if out == alu["prg"][idx:]:
            if idx == 0:
                return regA + i
            else:
                bt = find_quine(program_as_numbers, 8 * (regA + i), idx - 1)
                if bt:
                    return bt

def main():
    #with open("example.txt" if DO_EXAMPLE else "input.txt", "r") as file:
    with open("example.txt" if DO_EXAMPLE else "verify.txt", "r") as file:
        input = [line.strip() for line in file]

        alu = {
            "A": int(input[0].split(": ")[1]),
            "B": int(input[1].split(": ")[1]),
            "C": int(input[2].split(": ")[1]),
            "IP": 0,
            "out": [],
            "prg": [int(num) for num in input[4].split(": ")[1].split(",")],
        }
        print(f"Program:  {",".join(str(num) for num in alu["prg"])}")

        A = ",".join(str(num) for num in octpute(alu))
        print(f"Answer A: {A}")

        prg = alu["prg"][:] # make a copy just in case.
        B = find_quine(prg, 0, len(prg)-1)
        print(f"Answer B: {B}")

def exploratory_code_not_necessary_now_but_hey_ive_used_it_to_develop_the_solution_above():
    return False
    regA = 0
    for digit in reversed(program[:]):
        valid_i = []
        for i in range(8):
            rA = 8 * regA + i # register A would look like this with i
            rB = rA % 8          # 24 -> bst rA ==> rB := rA % 8
            rB ^= 3              # 13 -> bxl 3 --> rB := rB XOR 3
            rC = rA // (2 ** rB) # 75 -> cdv b --> c := rA // (2 exp rB)
            rB ^= 5              # 15 -> bxl 5 --> rB := rB XOR 5
            rA //= 8             # 03 -> adv 3 --> rA := rA // (2 exp 3)
            rB ^= rC             # 43 -> bxc --> rB := rB XOR rC [note: operand 3 is ignored.]
                                 # 55 -> OUT rB % 8
            if rB % 8 == digit:
                valid_i.append(i)
        if len(valid_i) == 0:
            print(f"Panic: i not found")
        else:
            print(f"found i={"/".join(str(k) for k in valid_i)}, for digit {digit}")
        regA *= 8
        regA += valid_i[0]

if __name__ == "__main__":
    main()
